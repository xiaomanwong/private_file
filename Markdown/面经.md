

### 快手

1. Https 的三次握手
2. 对称加密和非对称加密的区别
3. 三方库
   1. Glide 的优点
   2. Glide 的优化
   3. Glide 如何加载一张大图
   4. OkHttp 的优势
   5. OkHttp 拦截器如何处理重定向 302 请求
4. Handler 的 postDelay 实现， Message 的数据结构（随口提了一下）
5. Hander 的 post 方法和 View 的 post 方法有什么区别
6. 为什么 Activity 的 onResume 方法无法获取 View 的尺寸
7. View 的事件传递，如何扩大一个 View 的点击区域
8. GC 回收原理，分代回收，大 GC 和 小 gc
9. 内存泄漏场景和解决方案， LeakCanary 的实现
10. 二叉树深度计算

### 探探

1. GC 机制，回收算法，分代回收（问了很细，新生代内存区域的划分，处理细节）
2. JVM 虚拟机和 Android Davlink 的区别（我不会）
3. MVC， MVP，MVVM 的分层
4. Handler 的机制
5. Handler 的 post 和 View 的 post 区别
6. Activity 的生命周期变化（A->B,  A->B (透明的)， A 启动 Dialog ）
7. Activity 的加载流程，以及 DecorView 何时通过上面方法添加到 Activity 上
8. Acitivty, Window, DecorView 之间的关系
9. View 的绘制流程，onMeasure(widthMeasureSpec, heightMeasureSpec) 两个参数的作用
10. getMeasureWidth  和 getWidth 的区别
11. post，invalidate，requestLayout 的区别
12. Http 和 Https 的区别
13. HashMap，负载因子的作用，扩容机制，为什么容量是 2 的指数幂，针对哈希碰撞来展开问，红黑树



##  Service [生命周期](https://www.jianshu.com/p/ee224f18a4bd)



## RecyclerView 和 ListView

### 区别:

1. 缓存层级不同，缓存机制相似

   `ListView` 只有两层缓存机制

   *  mActiveViews
   * mScrapViews， 需要 bindView()

   `RecyclerView` 有四层缓存

   * mAttachedScrap
   *  mCacheViews
   *  mViewCacheExtension
   * mRecyclerPool, 需要 bindView(), 默认上限是 5

   缓存机制上

   * mActiveViews 和 mAttachedScrap 功能相似，意义在于快速重用屏幕上可见的列表 ItemView, 不需要重新 createView 和 bindView
   * mScrapViews 和 mCacheVies + mRecyclerViewPool 功能相似，意义在于缓存离开屏幕的 itemView ，目的是让即将进入屏幕的 itemView 复用
   * RecyclerView 的优势在于 a.mCacheView 的使用，可以左到屏幕外的列表项 ItemView 进入屏幕内时也无需 bindView() 快速复用； mRecyclerPool 可以共给多个 RecyclerView 共同使用，在特定场景下（ItemView 一致时）

   2. 缓存不同

      * RecyclerView 缓存的是 RecyclerView.ViewHolder， 避免了每次 createView 时，调用 findViewById + flag.通过匹配 position 获取目标位置缓存，无需重新 bindView
      * ListView 缓存的是 View,通过 pos 获取相应缓存，并重新 getView()

   3. 局部刷新

      结合 RecyclerView 的缓存机制，局部刷新时，会调用 `requestLayout` ，使整个 RecyclerView 进行重绘。onMeasure() -> onLayout() -> onDraw()

      1. dispatcherLayoutStep1(): 记录刷新前列表项的各种信息，用域动画的相关计算
      2. dispatcherLayoutStep2(): 真正的测量布局大小，位置
      3. dispatcherLayoutStep3(): 计算布局前后各 Item 的状态，如 Remove ,Add, Move ,Update, 必要时，执行动画

2. 使用上：

   1. RecyclerView 的 ViewHolder 的编写更规范，ListView 需要自己些
   2. Item 的复用 RecyclerView 更简洁，ListView 需要自己设置 Tag
   3. 布局的多样性，RecyclerView 横向、纵向、网格、流式

3. 布局上：

   1. ListView 支持 Header 和 Footer ，且不影响 Adapter 的 position；RecyclerView 不支持，需要自己编写，且影响 Adapter
   2. ListView 不支持局部刷新和动画，每次都是 notifyDataSetChange() 消耗资源
   3. ItemTouchHelper 为我们提供了很多可扩展的逻辑
   4. Item 点击事件， ListView 支持， RecyclerView 只提供了 ItemTouchListener
   5. 嵌套滚动问题

### RecyclerView 的性能优化

1. setItemViewCacheSize()： 设置缓存 view 的个数，按需（会影响内存）
2. setHasFixedSize(true): 插入和删除数据时，不会重新 请求布局
3. getExtralayoutSpace(): 额外空间大小，可以提前预加载
4. 复用 RecyclerViewPool（ItemView 要相同）

###  选择：

从性能上看， RecyclerView 并没有显著的提升，不需要更换原有的 ListView

如果数据频繁更新的场景，RecyclerView 的优势会明显一些，效果也更好



## LeakCanary

### 实现原理

LeakCanary.install 会单独开启一个进程处理分析和监听

* 利用 ActivityLifecycleCallback 检测生命周期变化（只监听 onDestroy）
* 使用 WeakReference + ReferenceQueue 监听对象的回收
* Application 通过 `process_name` 判断是否时任务进程
* 向 MessageQueue 中加入一个 `IdleHandler` ，等待线程空闲时处理任务
* 通过 ensureGone 方法
  * 将引用从队列中弹出来
  * 检测对象是否已经被回收
  * 如果没有回收，就手动 GC
  * 再次尝试并检测对象是否被回收
  * 如果没有被回收，就启用堆栈分析



## 网络优化

* DNS 解析优化，使用域名访问，会先通过 DNS 进行解析获取 IP 地址，首次大概要几百毫秒，可以通过直接用 IP 访问，也可以预防域名被劫持。
* 多运营商、多地部署，选择最优 IP 进行访问
* 连接复用，如开启 keep-alive
* 请求合并，
* 减小请求数据的大小， GZIP 压缩；减小返回数据大小， GZIP 压缩
* 静态资源缓存
* 简化数据格式， 用 JSON 替换 xml
* 增量更新，减少
* 大文件多线程下载，断电续传
* 数据缓存
* 

