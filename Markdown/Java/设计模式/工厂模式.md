---
title: 工厂模式
tag: 设计模式
categories: 设计模式 
---

![WX20211207-105938](https://s2.loli.net/2021/12/07/NcgsK2ErBj7TpuX.png)

一般情况下工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。

简单工厂和工厂方法原理比较简单，在实际的项目中也比较常用。抽象工厂比较复杂，在实际项目中也不常用。

## 简单工厂（Simple Factory)

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = null;
    if("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new JsonRuleConfigParser();
    } else if("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new PropertiesRuleConfigParser();
    } else {
      throw new  InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    
    String configText = "";
    // 从 ruleConfigFilePath 文件中读取配置文本到 configtext 中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }
  
  private String getFileExtension(String filePath) {
    return "json";
  }
}
```

为了让职责更加单一、代码更加清晰，我们可以进一步将 `createParse()`函数玻璃到一个独立的类中，让这个类只负责对象的创建。而这个类居室我们现在要讲的简单工厂模式类。

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    IRuleConfigParser  parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);
    if(parser == null) {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    
    String configText = "";
    // 从 ruleConfigFilePath  文件中读取配置文本到 configText 中
    RuleConfig ruleConfig = parse.parse(configText);
    return ruleConfig;
  }
}

public class RuleConfigParserFactory {
  public static IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new JsonRuleConfigParser();
    } else if("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new PropertiesRuleConfigParser();
    } 
    return parser;
  }
}
```

大部分工厂类都是以 `Factory` 单词结尾，但也不是必须。除此之外，工厂类中创建对象发方法一般都是 `create` 开头，但有的也命名为 `getInstance(), createInstance(), newInstance()`，有的甚至命名为 `valueOf()`等等，可根据具体业务和场景命名就好。

上述代码中，每次调用`RuleConfigParserFactory` 的 `createParser()`的时候，都要创建一个新的 `parser`。实际上， `parser` 可以服用，节省内存和对象创建的时间，可以将 `parser` 创建好缓存起来，当调用时，直接从缓存中获取就可。

## 工厂方法

上面有很多的 if 分支逻辑，如果有新增逻辑，就需要去修改代码，不符合开闭原则，我们可以利用多态处理.

```java
public interface IRuleConfigParserFatory{
  IRuleConfigParser createParser();
}

public class JsonRuleConfigParserFactory implement IRuleConfigParserFactory{
  @Override
  public IRuleConfigParser createParser(){
    return new JsonRuleConfigParser();
  }
}
public class XmlRuleConfigParserFactory implement IRuleConfigParserFactory{
  @Override
  public IRuleConfigParser createParser(){
    return new XmlRuleConfigParser();
  }
}
public class YamlRuleConfigParserFactory implement IRuleConfigParserFactory{
  @Override
  public IRuleConfigParser createParser(){
    return new YamlRuleConfigParser();
  }
}
public class PropertiesRuleConfigParserFactory implement IRuleConfigParserFactory{
  @Override
  public IRuleConfigParser createParser(){
    return new PropertiesRuleConfigParser();
  }
}
```

当我们新增一种 `parser` 的时候，只需要新增一个实现了 `IRuleConfigParserFactory` 接口的 `Factory` 即可。所以，**工厂方法模式比简单工厂模式更加符合开闭原则**

从上面的工厂方法的实现来看，一切很完美，但实际上有很大问题，在于这些工厂类的使用。我们用这些工厂类来实现 `RuleConfigSource` 的 `load()` 函数

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigPath);
    
    IRuleConfigParserFactory parserFactory = null;
    if("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new JsonRuleConfigParserFactory();
    } else if("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new XmlRuleConfigParserFactory();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new YamlRuleConfigParseFactoryr();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new PropertiesRuleConfigParserFactory();
    } else {
      throw new  InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    
    IRuleConfigParser parser = parserFactory.createParser();
    
    String configText = "";
    // 从 ruleConfigFilePath  文件中读取配置文本到 configText 中
    RuleConfig ruleConfig = parser.parser(confitText);
    return ruleConfig;
  }
  
  private String getFileExtension(String filePath) {
    //...解析⽂件名获取扩展名， ⽐如rule.json， 返回json
    return "json";
  }
}

```

工厂类对象的创建逻辑又耦合到 `load()`函数中国，跟最初的代码版本非常相似，引入工厂方法非但没有解决问题，反而设计更加复杂。

**我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象**。`RuleConfigParserFactoryMap`类是创建工厂对象的工厂类，`getParserFactory()`返回缓存的单例工厂对象。

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigPath);
    
    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    
    if(parserFactory == null) {
      throw new InvalidRuleConfigException("Rule config file format is not support: " + ruleConfigFilePath);
    }
    
    IRuleConfigParser parser = parserFactory.createParser();
    String configText = "";
    // 从 ruleConfigFilePath  文件中读取配置文本到 configText 中
    RuleConfig ruleConfig = parser.parser(confitText);
    return ruleConfig;
  }
  
  private String getFileExtension(String filePath) {
    //...解析⽂件名获取扩展名， ⽐如rule.json， 返回json
    return "json";
  }
}

// 因为⼯⼚类只包含⽅法， 不包含成员变量， 完全可以复⽤，
// 不需要每次都创建新的⼯⼚类对象， 所以， 简单⼯⼚模式的第⼆种实现思路更加合适。
public class RuleConfigParserFactoryMap {
  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap();
  
  static {
    cachedFactories.put("json", new JsonRuleConfigParserFactory());
    cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());
  }
  
  public static IRuleConfigParserFactory getParserFactory(String type) {
    if(type == null || type.isEmpty()) {
      return null;
    }
    
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
    return parserFactory;
  }
}
```

当我们需要配置新的规则解析器时，只需要创建新的 `parser` 类和 `parser factory` 类，并且在 `RuleConfigParserFactoryMap` 中，将新的 `parser factory` 对象 添加到 `cachedFactories` 中即可。代码改动就会非常少，符合开闭原则。

