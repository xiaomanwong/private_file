---
title: 原型模式
tag: 设计模式
categories: 设计模式 
---

![image-20211119173717815](https://i.loli.net/2021/11/19/8iXdcJoVFHWSR5r.png)

### 原型模式的原理和应用

如果对象的创建成本比较大，而同一个类的不同对象之间差别不打（大部分字段都相同），在这种情况下，我们可以利用已有对象进行复制的方式来创建新对象，以达到节省创建对象的目的。这种基于原型来创建对象的方式叫做**原型设计模式**。

### 何为“**对象的创建成本比较大**”

实际上创建对象包含内存申请、给成员变量复制这一流程，本省并不会花费太多时间，对于大部分业务系统来说，这点时间可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是过度设计，得不偿失。

但是如果对象中的数据需要经过复杂的计算才能得到（排序、hash等），或者需要从网络、数据库、文件等非常慢的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时操作。

### 深拷贝和浅拷贝

要实现原型模式，深拷贝和浅拷贝是主要技术手段，那么什么是浅拷贝呢

**浅拷贝**

浅拷贝只会复制索引，不会复制数据对象本身。浅拷贝得到的对象和原始对象共享数据，在 Java 语言中， Object 类的 `clone()` 方法执行的就是浅拷贝，它只拷贝对象中的基本数据类型的数据以及引用对象的内存地址，不会递归拷贝引用对象本身。

```java
public class Demo {
  private HashMap<String, SearchResult> currentKeyWords = new HashMap();
  private long lastUpdateTime = -1;
  
  
  public void refresh () {
    // 原型模式，拷贝已有对象的数据，更新少量数据
    List<SearchResult> toBeUpdateSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdateTime = lastUpdateTime;
    for(SearchResult result : toBeUpdateSearchWords) {
			if(result.getLastUpdateTime() > maxNewUpdateTime) {
        maxNewUpdateTime = result.getLastUpdateTime();
      }
      if(newKeyWords.containsKey(result.getKeyword())) {
        SearchResult old = newKeyWords.get(result.getKeyword());
        old.setCount(result.getCount());
        old.setLastUpdateTime(result.getLastUpdateTime());
      } else {
        newKeywords.put(result.getKeyword(), result);
      }
    }
    lastUpdateTime = maxNewUpateTime;
    currentKeywords = newKeywords;
  }
  
  private List<SerchResult> getSearchResult(long lastUpdateTime) {
    return null;
  }
}
```

**深拷贝**

而深拷贝则与浅拷贝相反，不仅仅会复制索引，还会复制数据本身，深拷贝之后得到的是一份完完全全独立的对象。

```java 
public class Demo {
  private HashMap<Strign, SearchResult> currentKeyWords = new HashMap();
  private long lastUpdateTime = -1;
  
  public void refresh () {
    HashMap<String, SearchResult> newKeywords = new HashMap();
    // 深拷贝
    for (HashMap.Entry<String , SearchResult> e : currentKeyWords.entrySet()) {
      SearchResult searchResult = e.getValue();
      SearchResult newSearchResult = new SearchResult(searchResult.getKeyword(), searchResult.getCount(), searchResult.getLastUpdateTime());
      newKeywords.put(e.getKey(), newSearchResult);
    }
    
    List<SearchResult> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdateTime = lastUpdateTime;
    for (SearchResult searchResult : toBeUpdatedSearchWords) {
      if (searchResult.getlastUpdateTime() > maxNewUpdatedTime) {
        maxNewUpdateTime = searchResult.getLastUpdateTime();
      }
      if (newKeyswords.containsKey(searchResult.getKeywords())) {
        SearchResult oldSearchResult = newKeywords.get(searchResult.getKeyword());
        oldSearchResult.setCount(searchResult.getCount());
        oldSearchResult.setLastUpdateTime(searchResult.getLastUpdateTime());
      } else {
        newKeywords.put(searchResult.getKeyword(), searchResult);
      }
    }
    
    lastUpdateTime = maxNewUpdatedTime;
    currentKeywords = newKeyWords;
  }
  
  private List<SearchResult> getSearchWords(long lastUpdateTime) {
    return null;
  }
}
```

**对比**

深拷贝要比浅拷贝耗时、耗内存空间。
