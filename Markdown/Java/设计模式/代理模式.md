---
title: 代理模式
tag: 设计模式
categories: 设计模式
---

代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。

## 静态代理

**目的**：

1. 通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向
2. 通过代理对象对原有业务的增强。

<!-- more -->

代理模式一般会有三个角色：

**抽象角色：** 指代理角色和真是角色对外提供的公共方法，一般为一个接口

**真实角色：** 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者

**代理角色：** 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。

静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。

静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。

## 动态代理

动态代理是指在使用时再创建代理类和实例

**有点：**

只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活

**缺点：**

效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。

应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。

## 动态代理的实现原理

`InvocationHandler` 和 `Proxy` 一个接口，一个类，再动态代理中时一定会用到的

`InvocationHandler` 接口是给动态代理类实现的，负责处理被代理对象的操作

`Proxy` 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法

```java
Proxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]{A.class, B.class}, new InvocationHandler(){
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        return method.invoke(a, objects);
    }
})
```

