---
title: 代理模式
tag: 设计模式
categories: 设计模式

---

![image-20211119173717815](https://i.loli.net/2021/11/19/8iXdcJoVFHWSR5r.png)

代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。

代理模式在不改变原始类（或叫被代理类）代码情况下，通过引入代理类来给原始类附加功能。

## 静态代理

**目的**：

1. 通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向
2. 通过代理对象对原有业务的增强。

<!-- more -->

代理模式一般会有三个角色：

**抽象角色：** 指代理角色和真是角色对外提供的公共方法，一般为一个接口

**真实角色：** 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者

**代理角色：** 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。

静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。

静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。

```java
public interface IUserController {
  UserVo login(String phoneNumber, String pwd);
  UserVo register(String phoneNumber, String pwd);
}

public class UserController implements IUserController {
  //.....省略其他属性和方法
  
  @Override
  public UserVo login(String phoneNumber, String pwd) {
    // login 逻辑
    
    // 返回 UserVo
  }
  
  @Override
  public UserVo register(String phoneNumber, String pwd) {
    // register 逻辑
    
    // return UserVo
  }
}

public class UserControllerProxy implements IUserController {
  private MetricsCollector metricsCollector;
  private UserController userController;
  
  public UserControllerProxy(UserController userController) {
    this.userController = userController;
    this.metricsCollector = new MetricsCollector();
  }
  
  @Override
  public UserVo login(String phoneNumber, String pwd) {
    long startTimestamp = System.currentTimeMillis();
    
    // 委托
    UserVo userVo = userController.login(phoneNumber, pwd);
    
    long endTimestamp = System.currentTimeMillis();
    long responseTime = endTimestamp - startTimestamp;
    RequestInfo requestInto = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    
    return userVo;
  }
  
  @Override
  public UserVo register(String phoneNumber, String pwd) {
		long startTimestamp = System.currentTimeMillis();
    
    // 委托
    UserVo userVo = userController.register(phoneNumber, pwd);
    long endTimestamp = System.currentTimeMillis();
    long responseTime = endTimestamp - startTimestamp;
    RequestInfo requestInto = new RequestInfo("register", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    return userVo;
  }
}

// UserControllerProxy 使用举例
// 因为原始类和代理类实现相同的接口，是机遇接口而非实现编程
// 将 UserController 类对象替换为 UserControllerProxy 对象，不需要改动太多代码
IUserController userController = new UserControllerProxy(new UserController());
```

参照机遇接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。但是如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的，我们也没有办法直接修改原始类，给它重新定义一个新接口。

对于这种外部类的扩展，一般可以采用继承的方式，我们让代理类继承原始类，然后扩展附加功能。

```java
public class UserControllerProxy implements UserController {
  private MetricsCollector metricsCollector;
  
  public UserControllerProxy() {
    this.metricsCollector = new MetricsCollector();
  }
  
  @Override
  public UserVo login(String phoneNumber, String pwd) {
    long startTimestamp = System.currentTimeMillis();
    
    // 委托
    UserVo userVo = super.login(phoneNumber, pwd);
    
    long endTimestamp = System.currentTimeMillis();
    long responseTime = endTimestamp - startTimestamp;
    RequestInfo requestInto = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    
    return userVo;
  }
  
  @Override
  public UserVo register(String phoneNumber, String pwd) {
		long startTimestamp = System.currentTimeMillis();
    
    // 委托
    UserVo userVo = super.register(phoneNumber, pwd);
    long endTimestamp = System.currentTimeMillis();
    long responseTime = endTimestamp - startTimestamp;
    RequestInfo requestInto = new RequestInfo("register", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    return userVo;
  }
}

// UserControllerProxy 使用举例
// 因为原始类和代理类实现相同的接口，是机遇接口而非实现编程
// 将 UserController 类对象替换为 UserControllerProxy 对象，不需要改动太多代码
IUserController userController = new UserControllerProxy();
```



## 动态代理

动态代理是指在使用时再创建代理类和实例，Java 依赖反射语法完成。

**优点：**

只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活

**缺点：**

效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。

应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。

## 动态代理的实现原理

`InvocationHandler` 和 `Proxy` 一个接口，一个类，再动态代理中时一定会用到的

`InvocationHandler` 接口是给动态代理类实现的，负责处理被代理对象的操作

`Proxy` 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法

```java
Proxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]{A.class, B.class}, new InvocationHandler(){
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        return method.invoke(a, objects);
    }
})
```



```java
public class MetricsCollectorProxy {
  private MetricsCollector metricsCollector;
  
  public MetricsCollectorProxy() {
    this.metricsCollector = new MetricsCollector();
  }
  
  public Object createProxy(Object proxiedObject) {
    Class<?> interfaces = proxiedObject.getClass().getInterfaces();
    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
  }
  
  private class DynamicProxyHandler implements InvocationHandler {
    private Object proxiedObject;
    public DynamicProxyHandler(Object proxiedObject) {
      this.proxiedObject = proxiedObject;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      long startTimestamp = System.currentTimeMillis();
      Object result = method.invoke(proxiedObject ,args);
      long endTimestamp = System.currentTimeMillis();
      long responseTime = endTimestamp - startTimestamp;
      String apiName = proxiedObject.getClass().getName() + ":" + method.getName();
      RequestInfo info = new RequestInfo(apiName, responseTime, startTimestamp);
      metricsCollector.recordRequest(info);
      return result;
    }
  }
}

// 使用举例
MetricsCollectorProxy proxy = new MetricsCollectorProxy();
IuserController userController = (IUserController) proxy.createProxy(new UserController());
```

## 代理模式应用

业务系统的非功能性需求开发

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、日志等。我们将这些附加功能与业务功能解耦，放在代理类中统一处理，让我们只需要关注业务方面的开发